function code = codeGene_sub(PRN)
% 生成北斗B1C信号导频分量子码,正逻辑
% 码长1800
% 在Weil码的某一位置循环截取,参数p确定,Weil码长3607
% Weil码由legendre序列生成,legendre序列一定,生成方式由参数w确定,w取值范围1~1803
% 参考《空间信号接口控制文件B1C 1.0》

% w参数表
wlist = [269,1448,1028,1324,822,5,155,458,310,959, ...
         1238,1180,1288,334,885,1362,181,1648,838,313, ...
         750,225,1477,309,108,1457,149,322,271,576, ...
         1103,450,399,241,1045,164,513,687,422,303, ...
         324,495,725,780,367,882,631,37,647,1043, ...
         24,120,134,136,158,214,335,340,661,889, ...
         929,1002,1149];

% p参数表
plist = [1889,1268,1593,1186,1239,1930,176,1696,26,1344, ...
         1271,1182,1381,1604,1333,1185,31,704,1190,1646, ...
         1385,113,860,1656,1921,1173,1928,57,150,1214, ...
         1148,1458,1519,1635,1257,1687,1382,1514,1,1583, ...
         1806,1664,1338,1111,1706,1543,1813,228,2871,2884, ...
         1823,75,11,63,1937,22,1768,1526,1402,1445, ...
         1680,1290,1245];

% 根据卫星编号选取w,p的值
w = wlist(PRN);
p = plist(PRN);

% legendre序列,-1表示逻辑1,1表示逻辑0
N = 3607;
L = ones(1,N); %全0逻辑
for x=0:N-1 %为1逻辑赋值
    k = mod(x*x,N);
    L(k+1) = -1;
end
L(1) = 1; %第一个为逻辑0

% Weil码序列
W = zeros(1,N);
for k=0:N-1
    W(k+1) = L(k+1) * L(mod(k+w,N)+1);
end

% 伪随机码
code = zeros(1,1800);
for n=0:1799
    code(n+1) = W(mod(n+p-1,N)+1);
end

% 显示头24个码片和尾24个码片（八进制）
% first = code(1:24)==-1; %01数组
% first = dec2bin(first)'; %二进制字符串
% first = bin2dec(first); %十进制数
% first = dec2base(first, 8); %八进制字符串
% disp(first)
% last = code(end-23:end)==-1; %01数组
% last = dec2bin(last)'; %二进制字符串
% last = bin2dec(last); %十进制数
% last = dec2base(last, 8); %八进制字符串
% disp(last)

code = -code;

end