%% 测试级联滤波器(一级滤波器独立)
% 振荡小,收敛慢,本地信号生成常速度驱动会带来相位误差
% X1(2) = X1(2) - X2(1);
% 区别在于二级滤波修正后一级滤波认为频率误差还有多少
% 这里认为频率误差已经变了
clear
clc

%% 仿真时间
T = 100;
dt = 0.01;
n = T/dt;

%% 实际信号参数
a0 = 10.6; %加速度
f0 = 1;    %频率
p0 = 0;    %相位
v = 0.01;  %相位测量噪声标准差

%% 本地信号参数
p = 0;  %本地相位
f1 = 0; %一级滤波估计的频率(驱动频率)
f2 = 0; %二级滤波估计的频率
a = 0;  %二级滤波估计的加速度

%% 一级滤波器
Phi1 = [1,dt;0,1];
P1 = diag([1,1])^2;
Q1 = diag([0,1])^2 * dt^2; %调节w
R1 = v^2; %相位测量噪声
H1 = [1,0];
X1 = [0;0];

%% 二级滤波器
Phi2 = [1,dt;0,1];
P2 = diag([1,1])^2;
Q2 = diag([0,0.01])^2 * dt^2;
R2 = 0.02^2; %一级滤波频率估计噪声
H2 = [1,0];

%% 计算
output = zeros(n,4);
for k=1:n
    %----实际信号生成
    p0 = p0 + f0*dt + 0.5*a0*dt^2; %相位更新
    f0 = f0 + a0*dt; %频率更新
    %----本地信号生成(常速度驱动)
%     p = p + f1*dt;
    %----本地信号生成(加速度驱动)
    p = p + f1*dt + 0.5*a*dt^2; %相位更新
    f1 = f1 + a*dt; %频率更新(加速度辅助)
    %----一级滤波
    Z = p - p0 + randn*v; %相位差量测
    X1 = Phi1*X1;
    P1 = Phi1*P1*Phi1' + Q1;
    K = P1*H1' / (H1*P1*H1'+R1);
    X1 = X1 + K*(Z-H1*X1);
    P1 = (eye(2)-K*H1)*P1;
    P1 = (P1+P1')/2;
    p = p - X1(1); %相位修正
    X1(1) = 0;
    f1 = f1 - X1(2); %频率修正
    X1(2) = 0;
    output(k,2) = f1 - f0; %一级滤波频率误差
    %----二级滤波
    f2 = f2 + a*dt; %二级滤波频率更新
    Z = f2 - f1; %频率误差量测
    P2 = Phi2*P2*Phi2' + Q2;
    K = P2*H2' / (H2*P2*H2'+R2);
    X2 = K*Z;
    P2 = (eye(2)-K*H2)*P2;
    P2 = (P2+P2')/2;
    f2 = f2 - X2(1); %频率修正
    a = a - X2(2); %加速度修正
    %----二级滤波对一级滤波频率赋值
    X1(2) = f2 - f1; %对于一级滤波来说,认为二级滤波的赋值是误差
    f1 = f2;
    %----存储
    output(k,1) = p - p0; %相位误差
    output(k,3) = f2 - f0; %二级滤波频率误差
    output(k,4) = a - a0; %加速度误差
end

%% 画图
figure('Name','相位误差');
plot(output(:,1))
grid on

figure('Name','频率误差');
plot(output(:,2))
hold on
plot(output(:,3))
grid on
legend('一级滤波','二级滤波')

figure('Name','加速度误差');
plot(output(:,4))
grid on